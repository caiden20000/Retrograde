/** Generated by ChatGPT */
import { useLayoutEffect, RefObject } from "react";

export function useResizeCanvas(
  canvasRef: RefObject<HTMLCanvasElement>,
  observeTarget: "self" | RefObject<HTMLElement> = "self"
) {
  useLayoutEffect(() => {
    const canvas = canvasRef.current;
    const targetEl = observeTarget === "self" ? canvas : observeTarget.current;
    if (!canvas || !targetEl) return;

    const ctx = canvas.getContext("2d");
    if (!ctx) return;

    const dpr = window.devicePixelRatio || 1;

    const resizeTo = (cssW: number, cssH: number) => {
      const pixelW = Math.max(1, Math.round(cssW * dpr));
      const pixelH = Math.max(1, Math.round(cssH * dpr));

      if (canvas.width !== pixelW || canvas.height !== pixelH) {
        // Only change the bitmap size
        canvas.width = pixelW;
        canvas.height = pixelH;

        // Keep drawing coordinates in CSS pixels
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }
    };

    const ro = new ResizeObserver((entries) => {
      const entry = entries[entries.length - 1];

      // Prefer content box size for precise sizing
      // Cross-browser: Firefox provides devicePixelContentBoxSize, others contentBoxSize
      // We want CSS pixels here, so use contentRect.width/height (CSS px).
      const { width, height } = entry.contentRect;
      resizeTo(width, height);
    });

    // If you're observing a container, ensure the canvas is set to fill it via CSS:
    // e.g. canvas { width: 100%; height: 100%; display: block; }
    ro.observe(targetEl);

    // Initial size
    const rect = targetEl.getBoundingClientRect();
    resizeTo(rect.width, rect.height);

    return () => ro.disconnect();
  }, [canvasRef, observeTarget]);
}
