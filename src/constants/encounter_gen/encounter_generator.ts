/**
 * 100% generated by ChatGPT. I just wanted something that worked.
 * I recommend running this with BUN.
 */

import * as fs from "fs";
import * as path from "path";

interface RawNode {
  name: string;
  varName: string;
  humanName: string;
  description: string;
  sideEffects: string[];
  options: Option[];
  isRoot: boolean;
}

interface Option {
  label: string;
  outcomes: Outcome[];
}

interface Outcome {
  chance: number;
  target: string; // Target varName
}

const inputDir = path.join(__dirname, "encounters");
const outputFile = path.join(__dirname, "generated_encounters.ts");

const generatedHeader = `import { newSideEffect } from "../../logic/sideEffect";
import { EncounterNode } from "../../types/EncounterNode";`;

function parseEncounterFile(content: string, filePrefix: string): RawNode[] {
  const lines = content.split(/\r?\n/);
  const nodes: RawNode[] = [];
  let current: Partial<RawNode> | null = null;
  let mode: "description" | "options" = "description";
  let buffer: string[] = [];
  let tempOutcomes: { label: string; lines: string[] }[] = [];

  const flushCurrent = () => {
    if (current && current.name) {
      current.description = buffer.join("\n").trim();

      // Calculate default chances for options with all implicit chances
      for (const opt of current.options || []) {
        const explicit = opt.outcomes.some((o) => o.chance !== -1);
        if (!explicit && opt.outcomes.length > 0) {
          const evenChance = 1 / opt.outcomes.length;
          for (const o of opt.outcomes) {
            o.chance = evenChance;
          }
        }
      }

      nodes.push(current as RawNode);
    }
    buffer = [];
  };

  for (const line of lines) {
    const trimmed = line.trim();
    if (!trimmed) {
      flushCurrent();
      current = null;
      continue;
    }

    const nodeHeader = trimmed.match(/^([#]?)\(([^)]+)\)\s*(.*)$/);
    if (nodeHeader) {
      flushCurrent();
      const [, rootMark, nodeName, humanName] = nodeHeader;
      const cleanName = nodeName.trim().replace(/\s+/g, "_");
      current = {
        name: nodeName.trim(),
        varName: `${filePrefix}__${cleanName}`,
        humanName: humanName.trim(),
        description: "",
        sideEffects: [],
        options: [],
        isRoot: rootMark === "#",
      };
      mode = "description";
      continue;
    }

    if (!current) continue;

    if (trimmed.startsWith(">")) {
      current.sideEffects?.push(trimmed.substring(1).trim());
    } else if (trimmed.startsWith("[")) {
      mode = "options";
      const label = trimmed.slice(1, -1);
      current.options?.push({ label, outcomes: [] });
    } else if (trimmed.startsWith("-")) {
      const match = trimmed.match(/^-\s*(?:\(([^)]+)\)\s*)?(\S+)/);
      if (match && current.options?.length) {
        const [, chanceRaw, target] = match;
        const chance = chanceRaw ? parseFloat(chanceRaw) : -1;
        current.options[current.options.length - 1].outcomes.push({
          chance,
          target: `${filePrefix}__${target.replace(/\s+/g, "_")}`,
        });
      }
    } else {
      buffer.push(trimmed);
    }
  }

  flushCurrent();
  return nodes;
}

function transpileNodes(allNodes: RawNode[]): string {
  const nodeMap = new Map<string, RawNode>();
  for (const node of allNodes) nodeMap.set(node.varName, node);

  const declared = new Set<string>();
  const outputLines: string[] = [generatedHeader];

  function emitNode(node: RawNode) {
    if (declared.has(node.varName)) return;
    for (const opt of node.options) {
      for (const outcome of opt.outcomes) {
        const targetNode = nodeMap.get(outcome.target);
        if (targetNode) emitNode(targetNode);
      }
    }
    const sideEffectStr = node.sideEffects.length
      ? `newSideEffect({ namedEffects: [${node.sideEffects
          .map((e) => `"${e}"`)
          .join(", ")} ] })`
      : "null";

    const optionsStr = node.options
      .map((opt) => {
        let outcomesStr = "";
        if (opt.outcomes.length === 0) {
          outcomesStr = `{ chance: 1, node: null, nodeType: "null" }`;
        } else {
          outcomesStr = opt.outcomes
            .map((o) => {
              const targetKey = o.target.replace(/\s+/g, "_");
              const refNode = nodeMap.get(targetKey);
              if (!refNode) {
                return `// Unknown node: ${o.target}`;
              }
              return `{ chance: ${o.chance}, node: ${refNode.varName}, nodeType: "EncounterNode" }`;
            })
            .filter((s) => !s.startsWith("// Unknown"))
            .join(",\n        ");
        }
        return `{
      label: "${opt.label}",
      outcomes: [
        ${outcomesStr}
      ]
    }`;
      })
      .join(",\n  ");

    outputLines.push(`const ${node.varName}: EncounterNode = {
  description: \`${node.description}\`,
  sideEffect: ${sideEffectStr},
  options: [
  ${optionsStr}
  ]
};
`);

    declared.add(node.varName);
  }

  const rootNames: string[] = [];
  for (const node of allNodes) {
    if (node.isRoot) rootNames.push(node.varName);
    emitNode(node);
  }

  outputLines.push(`export const allRootNodes = [${rootNames.join(", ")}];
`);
  return outputLines.join("\n");
}

function main() {
  const files = fs
    .readdirSync(inputDir)
    .filter((f) => f.endsWith(".encounter"));
  const allNodes: RawNode[] = [];
  for (const file of files) {
    const fullPath = path.join(inputDir, file);
    const content = fs.readFileSync(fullPath, "utf-8");
    const filePrefix = path.basename(file, ".encounter").replace(/\W+/g, "_");
    const nodes = parseEncounterFile(content, filePrefix);
    allNodes.push(...nodes);
  }
  const code = transpileNodes(allNodes);
  fs.writeFileSync(outputFile, code, "utf-8");
  console.log(`Generated ${outputFile}`);
}

main();
